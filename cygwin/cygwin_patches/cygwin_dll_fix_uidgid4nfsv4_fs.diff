# prototype fix for Cygwin DLL to handle uids/gids correctly on
# NFSv4 filesystems.
# Without LDAP they use Cygwin or UWIN to obtain the uid/gid for files,
# which breaks the assumptions in |fhandler_base::fstat_by_nfs_ea()|
# and causes it to map all uid/gid values into the Unix_User+/Unix_Group SID
# range
diff --git a/winsup/cygwin/fhandler/disk_file.cc b/winsup/cygwin/fhandler/disk_file.cc
index d54d3747e..92a54d9db 100644
--- a/winsup/cygwin/fhandler/disk_file.cc
+++ b/winsup/cygwin/fhandler/disk_file.cc
@@ -239,8 +239,12 @@ fhandler_base::fstat_by_nfs_ea (struct stat *buf)
 	  domain = cygheap->dom.get_rfc2307_domain ();
 	  if ((ldap_open = (cldap.open (domain) == NO_ERROR)))
 	    map_uid = cldap.remap_uid (nfs_attr->uid);
-	  if (map_uid == ILLEGAL_UID)
-	    map_uid = MAP_UNIX_TO_CYGWIN_ID (nfs_attr->uid);
+	  if (map_uid == ILLEGAL_UID) {
+            if (pc.has_acls())
+              map_uid = nfs_attr->uid;
+            else
+              map_uid = MAP_UNIX_TO_CYGWIN_ID (nfs_attr->uid);
+          }
 	  cygheap->ugid_cache.add_uid (nfs_attr->uid, map_uid);
 	  buf->st_uid = map_uid;
 	}
@@ -258,8 +262,12 @@ fhandler_base::fstat_by_nfs_ea (struct stat *buf)
 	  domain = cygheap->dom.get_rfc2307_domain ();
 	  if ((ldap_open || cldap.open (domain) == NO_ERROR))
 	    map_gid = cldap.remap_gid (nfs_attr->gid);
-	  if (map_gid == ILLEGAL_GID)
-	    map_gid = MAP_UNIX_TO_CYGWIN_ID (nfs_attr->gid);
+	  if (map_gid == ILLEGAL_GID) {
+            if (pc.has_acls())
+              map_gid = nfs_attr->gid;
+            else
+	      map_gid = MAP_UNIX_TO_CYGWIN_ID (nfs_attr->gid);
+          }
 	  cygheap->ugid_cache.add_gid (nfs_attr->gid, map_gid);
 	  buf->st_gid = map_gid;
 	}
